# Martin Fowler 团队说 SDD 工具都做错了，但他们指出了正确的问题

> 2026-02-15 | 基于 Martin Fowler 团队 Birgitta Böckeler 的 Spec-Driven Development 工具对比文章

---

## 一篇重要的文章

Martin Fowler 网站最近发布了一篇关于 Spec-Driven Development（SDD）工具的对比文章。作者 Birgitta Böckeler 来自 Thoughtworks，她亲手测试了三个 SDD 工具——Kiro、GitHub spec-kit、Tessl——然后给出了一个出乎很多人意料的结论：

**现有的 SDD 工具可能在让事情变得更糟。**

她用了一个精准的德语词 Verschlimmbesserung——越改越糟。

这不是一篇吹捧新概念的文章。这是一个有经验的工程师在说：方向没问题，但你们走的路不对。

## SDD 的三层定义

文章把 Spec-Driven Development 分成了三个层级：

**第一层：Spec-first。** 写代码前先写 spec。最基础，大多数人理解的 SDD 就是这个。

**第二层：Spec-anchored。** Spec 不只是开头写一次，而是随代码一起演进。Spec 和代码保持同步。

**第三层：Spec-as-source。** 最激进——spec 本身就是源代码，实现代码完全自动生成。人只维护 spec。

现有工具大多停在第一层和第二层之间。第三层还是理论。

## 四个核心问题

Böckeler 在实际测试中发现了四个问题。每一个都值得仔细看。

### 问题 1：大锤砸坚果

修一个小 bug，Kiro 会自动生成 4 个 user stories 和 16 个 acceptance criteria。

这就像你想换个灯泡，有人要求你先提交一份房屋电路改造方案。工具没有能力判断任务的轻重，所有事情都走同样重的流程。

**本质问题：** 工具把流程当成了产品，而不是把结果当成产品。

### 问题 2：Review 负担

spec-kit 会生成大量 markdown 文件。内容重复，审核起来很累。

这导致一个讽刺的结果：spec 的目的是让人和 AI 对齐，但如果 spec 本身让人不想看，对齐就不会发生。最终 spec 变成了一堆没人读的文档——和十年前的 PRD 一模一样。

**本质问题：** 生成文档不等于传递信息。如果产出物让人不想看，它的价值就是零。

### 问题 3：AI 不听 spec

即使写了详细的 spec，AI agent 还是会忽略指令、过度执行、创建重复代码、违反架构约定。

这揭示了一个根本矛盾：SDD 工具假设 spec 越详细，AI 执行越准确。但现实中 AI 的行为是概率性的，不是确定性的。再详细的 spec 也不能消除 AI 的不确定性。

**本质问题：** Spec 不是控制命令，它是方向指引。把 spec 当控制系统来设计，注定会失望。

### 问题 4：功能需求和技术方案分不清

所有工具都在"做什么"和"怎么做"之间摇摆不定。一份 spec 里混着产品决策和技术实现，谁该看什么、谁该改什么，完全模糊。

**本质问题：** 这些工具没有定义清楚自己服务谁。它们试图同时服务 PM 和工程师，结果两边都不满意。

## 历史不会重复，但会押韵

文章里最有深度的部分是历史类比。

Böckeler 把 SDD 和 2000 年代的 Model-Driven Development（MDD）做了对比。MDD 当年也承诺"用高层模型自动生成代码"，最终因为模型和代码之间的抽象层不匹配而失败。

SDD 面临同样的风险：如果 spec 和代码之间的抽象距离太大，spec 就变成了一个需要维护的额外负担，而不是减轻负担的工具。

这个类比很重要。它提醒我们：**不是所有听起来对的方向最终都会成功，关键在于执行方式。**

## SDD 工具做错了什么

回看这四个问题，有一个共同的根源：

**现有 SDD 工具是工程师为工程师做的。**

它们关心的是：怎么让 spec 更完整、怎么让工作流更规范、怎么让 AI 更听话。

但真正的问题不在这里。

真正的问题是：**在 AI 能写代码之后，"决定做什么"变成了价值链上最重要的一环。** 而这个环节的主角不是工程师，是产品决策者——可能是 PM，可能是独立创业者，可能是任何一个有想法但不确定该怎么做的人。

Kiro、spec-kit、Tessl 都在优化"怎么把需求传给 AI"这个环节。但它们跳过了一个更上游的问题："需求本身对不对？"

## 另一种思路：先想清楚，再写 spec

PM-Quill 是一个从不同角度切入的工具。它不试图解决"怎么写更好的 spec"，而是解决"怎么做更好的产品决策"。

四步工作流：

1. **`/spec`** — 不是生成技术文档，而是帮你想清楚三个问题：给谁用、解决什么问题、不做什么。核心功能限制在 3 个以内。
2. **`/feasibility`** — 不是直接写代码，而是先评估"这个东西值不值得做"。给出 2-3 个方案对比、工作量估算、风险识别。
3. **`/plan`** — 确认方向后再拆任务。每个任务带验收标准，直接交给编码 AI 执行。
4. **`/review`** — 做完之后回顾：什么决策是对的，什么是错的，学到了什么。

这个设计背后的哲学和 SDD 工具完全不同：

**SDD 工具说：** "写一份详细的 spec，AI 就能帮你写对代码。"

**PM-Quill 说：** "先想清楚做什么，再让 AI 去写。"

区别在于，PM-Quill 不把 spec 当成 AI 的控制命令，而是当成人的决策记录。它服务的不是 AI 的执行质量，而是人的思考质量。

## 回应 Martin Fowler 团队的四个问题

把 PM-Quill 的设计逻辑放到 Böckeler 指出的四个问题里看：

### 大锤砸坚果 → 按任务大小调节

PM-Quill 的 `/spec` 不会对每个需求都生成 16 个 acceptance criteria。一个小改动可能只需要一句话的 spec。核心功能限制在 3 个以内的设计哲学，本身就在对抗过度规范化。

### Review 负担 → 让人想看，而不是必须看

所有产出物都是简洁的 markdown。不是因为 markdown 好，而是因为它强迫精简。当你的 spec 只有一页，人就会看。当你的 spec 有 20 页，人就不看了。

### AI 不听 spec → 不指望 AI 听话

PM-Quill 不把 spec 当成 AI 的指令集。`/plan` 生成的任务是给编码 AI 的输入，但 `/spec` 是给人的决策框架。两者分开。AI 在执行层面的不确定性，不影响人在决策层面的确定性。

### 功能/技术分不清 → 明确分层

`/spec` 只管"做什么"和"不做什么"。`/feasibility` 管"怎么做"的技术可行性。`/plan` 管"具体怎么拆"。三个步骤，三个层次，不混在一起。

## 真正的机会在哪里

Martin Fowler 团队这篇文章的价值不在于它评测了三个工具。它的价值在于它把一个正在形成的行业共识清晰地说出来了：

**AI 让"怎么写代码"变得不那么重要了。"写什么代码"才是新的瓶颈。**

SDD 工具试图用工程化的方式解决这个瓶颈。但工程化的方式——更多文档、更严格的流程、更详细的 spec——恰好和这个时代的趋势相反。这个时代需要的是更轻、更快、更少的流程开销。

真正的机会不是做一个更好的 SDD 工具。而是做一个帮人想清楚的工具。

spec-kit 解决的是"怎么把想法变成 spec"。
PM-Quill 解决的是"怎么确认这个想法值得变成 spec"。

差一步，但那一步是最重要的。

## 一句话总结

Martin Fowler 团队证明了 SDD 工具的方向是对的、执行是错的。正确的做法不是让 spec 更重，而是让决策更轻。

---

*基于 Martin Fowler 网站文章 "Exploring Gen AI: SDD Tools" (Birgitta Böckeler, 2026) 的分析。*
*PM-Quill: [pm.simprr.com](https://pm.simprr.com)*
