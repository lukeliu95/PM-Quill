# Martin Fowler チームは SDD ツールが間違っていると言ったが、彼らは正しい問題を指摘した

> 2026-02-15 | Martin Fowler チームの Birgitta Böckeler による Spec-Driven Development ツール比較記事に基づく

---

## 重要な記事

Martin Fowler のウェブサイトで最近、Spec-Driven Development（SDD）ツールの比較記事が公開されました。Thoughtworks の Birgitta Böckeler 氏が、Kiro、GitHub spec-kit、Tessl という3つの SDD ツールを実際にテストし、多くの人の予想を裏切る結論を出しました：

**既存の SDD ツールは、事態を悪化させている可能性がある。**

彼女はドイツ語の的確な単語「Verschlimmbesserung（改悪）」を使いました——良くしようとして、かえって悪くしてしまうことです。

これは新しいコンセプトを称賛する記事ではありません。経験豊富なエンジニアが、「方向性は間違っていないが、あなたたちが進んでいる道は間違っている」と言っているのです。

## SDD の3つの定義

記事では、Spec-Driven Development を3つのレベルに分類しています：

**レベル1：Spec-first（スペックファースト）。** コードを書く前にスペックを書く。最も基本的で、多くの人が理解している SDD はこれです。

**レベル2：Spec-anchored（スペックアンカード）。** スペックは最初に書くだけでなく、コードと共に進化する。スペックとコードが同期し続ける状態。

**レベル3：Spec-as-source（スペックアズソース）。** 最も急進的——スペック自体がソースコードとなり、実装コードは完全に自動生成される。人間はスペックのみをメンテナンスする。

既存のツールの多くはレベル1とレベル2の間に留まっています。レベル3はまだ理論の段階です。

## 4つの核心的な問題

Böckeler 氏は実際のテストで4つの問題を発見しました。どれも詳しく見る価値があります。

### 問題 1：ナッツを割るのにハンマーを使う（大げさすぎる）

小さなバグを修正するだけでも、Kiro は自動的に4つのユーザーストーリーと16の受け入れ基準（Acceptance Criteria）を生成します。

これは、電球を交換したいだけなのに、家の配線改修計画を提出するよう求められるようなものです。ツールにはタスクの重要度を判断する能力がなく、すべての事柄に対して同じ重厚なプロセスを適用してしまいます。

**本質的な問題：** ツールが「結果」ではなく「プロセス」をプロダクトとして扱っていること。

### 問題 2：レビューの負担

spec-kit は大量の Markdown ファイルを生成します。内容は重複しており、レビューするのは疲れる作業です。

これは皮肉な結果を招きます。スペックの目的は人間と AI の認識を合わせることですが、スペック自体が読む気を失わせるものであれば、認識合わせは起こりません。最終的にスペックは、誰も読まないドキュメントの山になります——10年前の PRD（製品要件定義書）と全く同じです。

**本質的な問題：** ドキュメントを生成することは、情報を伝達することと同じではありません。成果物が読む気を起こさせないものであれば、その価値はゼロです。

### 問題 3：AI はスペックを聞かない

詳細なスペックを書いても、AI エージェントは指示を無視したり、過剰に実行したり、重複コードを作成したり、アーキテクチャの規約に違反したりします。

これは根本的な矛盾を明らかにしています。SDD ツールは「スペックが詳細であればあるほど、AI は正確に実行する」と仮定しています。しかし現実には、AI の振る舞いは確率的であり、決定的ではありません。どれだけ詳細なスペックでも、AI の不確実性を排除することはできません。

**本質的な問題：** スペックは制御コマンドではなく、方向性の指針です。スペックを制御システムとして設計すれば、失望することになります。

### 問題 4：機能要件と技術案の混同

すべてのツールが「何をするか（What）」と「どうやるか（How）」の間で揺れ動いています。1つのスペックの中に製品の決定事項と技術的な実装が混在しており、誰が何を見るべきか、誰が何を修正すべきかが完全に曖昧です。

**本質的な問題：** これらのツールは、誰にサービスを提供しているのかを明確に定義していません。PM とエンジニアの両方に同時にサービスを提供しようとして、結果的にどちらも満足させていません。

## 歴史は繰り返さないが、韻を踏む

記事の中で最も深みのある部分は、歴史的な類似点についてです。

Böckeler 氏は SDD を2000年代の Model-Driven Development（MDD）と比較しました。MDD も当時、「高レベルのモデルからコードを自動生成する」と約束しましたが、最終的にはモデルとコードの間の抽象化レイヤーの不一致により失敗しました。

SDD も同様のリスクに直面しています。もしスペックとコードの間の抽象度の距離が大きすぎると、スペックは負担を軽減するツールではなく、メンテナンスが必要な余分な負担になってしまいます。

この類似点は重要です。それは私たちに思い出させてくれます：**正しそうに聞こえるすべての方向性が最終的に成功するわけではなく、重要なのは実行方法であると。**

## SDD ツールは何を間違えたのか

これら4つの問題を振り返ると、共通の根源があります：

**既存の SDD ツールは、エンジニアがエンジニアのために作ったものである。**

彼らが気にしているのは、どうすればスペックをより完全にできるか、どうすればワークフローをより規範的にできるか、どうすれば AI をより従順にできるか、ということです。

しかし、本当の問題はそこではありません。

本当の問題はこれです：**AI がコードを書けるようになった後、「何をするかを決めること」がバリューチェーンの中で最も重要なリンクになったということです。** そして、このリンクの主役はエンジニアではなく、プロダクトの意思決定者です——それは PM かもしれないし、独立した起業家かもしれないし、アイデアはあるがどうすればいいかわからない誰かかもしれません。

Kiro、spec-kit、Tessl はすべて「どうやって要件を AI に伝えるか」というリンクを最適化しています。しかし、彼らはより上流の問題、「その要件自体は正しいのか？」をスキップしています。

## 別のアプローチ：まず考えてから、スペックを書く

PM-Quill は異なる角度から切り込むツールです。「どうやってより良いスペックを書くか」を解決しようとするのではなく、「どうやってより良いプロダクトの意思決定をするか」を解決します。

4ステップのワークフロー：

1.  **`/spec`** — 技術文書を生成するのではなく、3つの問題を考えるのを助けます：誰が使うのか、どんな問題を解決するのか、何をしないのか。コア機能は3つ以内に制限されます。
2.  **`/feasibility`** — すぐにコードを書くのではなく、まず「これを作る価値があるか」を評価します。2-3の案の比較、工数見積もり、リスク識別を提示します。
3.  **`/plan`** — 方向性が確認できたらタスクを分解します。各タスクには受け入れ基準があり、コーディング AI に直接渡して実行させることができます。
4.  **`/review`** — 完了後に振り返ります：どの決定が正しかったか、何が間違っていたか、何を学んだか。

この設計の背後にある哲学は、SDD ツールとは全く異なります：

**SDD ツールは言います：** 「詳細なスペックを書けば、AI が正しいコードを書いてくれる。」

**PM-Quill は言います：** 「まず何をするかよく考えてから、AI に書かせよう。」

違いは、PM-Quill がスペックを AI への制御コマンドとしてではなく、人間の意思決定の記録として扱っている点にあります。それがサービスを提供するのは、AI の実行品質ではなく、人間の思考品質に対してです。

## Martin Fowler チームの4つの問題への回答

PM-Quill の設計ロジックを、Böckeler 氏が指摘した4つの問題に当てはめてみましょう：

### ハンマーでナッツを割る → タスクの大きさに応じて調整

PM-Quill の `/spec` は、すべての要件に対して16の受け入れ基準を生成したりしません。小さな変更なら、一言のスペックで済むかもしれません。コア機能を3つ以内に制限する設計哲学自体が、過度な規範化に対抗しています。

### レビューの負担 → 見たくなるものにする（義務ではなく）

すべての成果物は簡潔な Markdown です。Markdown が優れているからではなく、それが簡潔さを強制するからです。スペックが1ページしかなければ、人は読みます。20ページもあったら、誰も読みません。

### AI はスペックを聞かない → AI が従順であることを期待しない

PM-Quill はスペックを AI の命令セットとして扱いません。`/plan` で生成されるタスクはコーディング AI への入力ですが、`/spec` は人間のための意思決定フレームワークです。両者は分かれています。実行レベルでの AI の不確実性は、意思決定レベルでの人間の確実性に影響を与えません。

### 機能/技術の混同 → 明確な階層化

`/spec` は「何をするか」と「何をしないか」だけを扱います。`/feasibility` は「どうやるか」の技術的な実現可能性を扱います。`/plan` は「具体的にどう分解するか」を扱います。3つのステップ、3つの階層があり、混ざり合いません。

## 本当の機会はどこにあるか

Martin Fowler チームのこの記事の価値は、3つのツールをレビューしたことにあるのではありません。その価値は、形成されつつある業界のコンセンサスを明確に述べたことにあります：

**AI によって、「どうコードを書くか」はそれほど重要ではなくなった。「何のコードを書くか」こそが新しいボトルネックである。**

SDD ツールは、エンジニアリング的なアプローチでこのボトルネックを解決しようとしています。しかし、エンジニアリング的なアプローチ——より多くのドキュメント、より厳格なプロセス、より詳細なスペック——は、まさにこの時代のトレンドとは逆行しています。この時代が必要としているのは、より軽く、より速く、より少ないプロセスオーバーヘッドです。

本当の機会は、より良い SDD ツールを作ることではありません。人が考えを整理するのを助けるツールを作ることです。

spec-kit が解決するのは「どうやってアイデアをスペックにするか」です。
PM-Quill が解決するのは「このアイデアがスペックにする価値があるかをどう確認するか」です。

一歩の違いですが、その一歩が最も重要なのです。

## 一言まとめ

Martin Fowler チームは、SDD ツールの方向性は正しいが、実行方法は間違っていることを証明しました。正しいやり方は、スペックを重くすることではなく、意思決定を軽くすることです。

---

*Martin Fowler のウェブサイト記事 "Exploring Gen AI: SDD Tools" (Birgitta Böckeler, 2026) の分析に基づく。*
*PM-Quill: [pm.simprr.com](https://pm.simprr.com)*
